# -*- coding: utf-8 -*-
"""
Created on Wed Aug 14 11:14:10 2024

@author: Hang Min

Run testing of the trained model for sex estimation
"""

import os
import sys
# Add the parent directory to the Python path
current_folder = os.path.dirname(os.path.abspath(__file__))
parent_folder_path = os.path.abspath(os.path.join(current_folder, '..'))
sys.path.append(parent_folder_path)
import numpy as np
import time
import argparse
import torch
from torch.utils.data import DataLoader
from networks.resnet import ResNet_two_output, ResNet_auxiliary, ResNet_single_output
import pandas as pd
from data.Custom_data_loader import load_data
from data.Custom_data_loader import load_data_image_skull
from data.Custom_data_loader import load_data_skull
from data.utils import average_walkder_scores, round_to_nearest_walker_score
from testing.predict import test_model_two_ouputs, test_model_single_output, assign_value_to_key

if __name__ == '__main__':
    
    start = time.time() 
    
    parser = argparse.ArgumentParser()
    parser.add_argument('--mdl_name', help='name of the output model', type=str, default="ResNet.pt")
    parser.add_argument('--mdl_type', help='the type of models: ResNet_two_output, ResNet_auxiliary and ResNet_single_output', type=str, default="ResNet_two_output")
    parser.add_argument('--input_mode', help='the type of input: whole CT image, image and skull mask, or skull', type=str, default='skull')
    parser.add_argument('--batch', help='batch size', type=int, default=4)
    parser.add_argument('--num_metrics', help='number of Walker traits (bilateral)', type=int, default=7)
    parser.add_argument('--num_classes', help='number of biological sex classes, 0 (male) or 1 (female). Since this is binary classification, it will be set as 1.', type=int, default=1)
            
    args = parser.parse_args()        
    batch = args.batch
       
    # Mapping of model types to functions
    model_functions = {
        "ResNet_two_output": ResNet_two_output,
        "ResNet_auxiliary": ResNet_auxiliary,
        "ResNet_single_output": ResNet_single_output
    }
    
    model_function = model_functions.get(args.mdl_type)
    
    if args.mdl_type ==  "ResNet_single_output":
        if_walker_score = False
    else:
        if_walker_score = True
    '''
    Build model
    '''    
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    
    '''
    Start training the network
    '''    
    data_path = '/datasets/work/hb-radiationtqa/work/Cranial CT data/Cranial CT nifti isotropic crop/'
    seg_path = '/datasets/work/hb-radiationtqa/work/Cranial CT data/Cranial CT isotropic segmentations crop/'
    case_partition_path = '/datasets/work/hb-c-radiation/work/Python_env/myenv_ct_gender/cranial_ct_gender_classification/data_process/Case_partition.xlsx'
    test_spreadsheet = pd.read_excel(case_partition_path, 'Test')
    performance_save_folder = os.path.join(parent_folder_path, 'model__' + args.mdl_type + '__' + args.input_mode, 'test')#test_torch2
    os.makedirs(performance_save_folder, exist_ok=True)
    
    test_performance_save_path = os.path.join(performance_save_folder, 'test_pred_output.xlsx')
    
    writer_test = pd.ExcelWriter(test_performance_save_path, engine='xlsxwriter')   
    if  args.input_mode == 'image':
        # Use image only input
        print('Using whole image as input:')
        test_dataset = load_data(data_path, test_spreadsheet, im_shape = (128,128,128), if_aug = 0)
        
        model = model_function(channel=1, filters=[32, 64, 128, 256], num_metrics=args.num_metrics, num_classes=args.num_classes)
            
    elif args.input_mode == 'image_skull':
        # using image + bone mask
        print('Using image and skull mask as 2 channel inputs, skull mask generated by total segmentator:')
        test_dataset = load_data_image_skull(data_path, test_spreadsheet, seg_path=seg_path, im_shape = (128,128,128), 
                                                  if_aug = 0)
        
        model = model_function(channel=2, filters=[32, 64, 128, 256], num_metrics=args.num_metrics, num_classes=args.num_classes)
        
    elif args.input_mode == 'skull':
        # Using image and bone mask intersection (bone mask region only)
        print('Using skull region intersection between image and skull mask as input, skull mask generated by total segmentator:')
        test_dataset = load_data_skull(data_path, test_spreadsheet, seg_path=seg_path, im_shape = (128,128,128), 
                                                if_aug = 0)
        
        model = model_function(channel=1, filters=[32, 64, 128, 256], num_metrics=args.num_metrics, num_classes=args.num_classes)
        
    else:
        
        raise ValueError("The input type is not recognized!")

    test_dataLoader = DataLoader(
        dataset = test_dataset,
        batch_size = 1,
        shuffle = False
    )
    print('Number of testing images: ', len(test_dataset))
    
    Test_Pred1s = []
    Test_Pred2s = []
    
    keys = ['GLA\n(1 g)', 'SUP-L\n(2 om)', 'SUP-R\n(3 om)', 'MEN\n(4 em)', 'MAS-L\n(5 ms)', 'MAS-R\n(6 ms)', 'NUC\n(7 nu)']# test_spreadsheet.columns.tolist()[1:-1]
    # print('Walker traits: ', keys)
    
    '''
    # Perform OOF validation and testing
    '''
    
    if args.mdl_type == 'ResNet_two_output' or args.mdl_type == 'ResNet_auxiliary':
        
        for fold in range(0,5):
           
            weight_path = os.path.join(parent_folder_path, 'model__' + args.mdl_type + '__' + args.input_mode, 'exp' + str(fold), args.mdl_name)
            
            model.to(device)
            model.load_state_dict(torch.load(weight_path))#, map_location=torch.device('cpu')
            model.eval()
                         
            test_pred1s, test_pred2s = test_model_two_ouputs (test_dataLoader, model, device)
                                        
            test_pred1s = np.array(test_pred1s)
            test_pred2s = np.array(test_pred2s)
            
            test_performance_dict = {'Sample ID': test_spreadsheet['Sample ID'].tolist()}
            test_performance_dict = assign_value_to_key (test_performance_dict, keys, test_pred1s)
            test_performance_dict['Pred prob'] = list(test_pred2s)
            
            test_performance = pd.DataFrame(test_performance_dict)
            test_performance.to_excel(writer_test, sheet_name='Test'+str(fold), index=False) 
                   
        
    elif args.mdl_type == 'ResNet_single_output': 
        
        for fold in range(0,5):
            weight_path = os.path.join(parent_folder_path, 'model__' + args.mdl_type + '__' + args.input_mode, 'exp' + str(fold), args.mdl_name)
            
            model.to(device)
            model.load_state_dict(torch.load(weight_path))#, map_location=torch.device('cpu')
            model.eval()
                                 
            test_pred2s = test_model_single_output (test_dataLoader, model, device)
            
            test_pred2s = np.array(test_pred2s)
            
            test_performance_dict = {'Sample ID': test_spreadsheet['Sample ID'].tolist()}
            test_performance_dict['Pred prob'] = list(test_pred2s)
            
            test_performance = pd.DataFrame(test_performance_dict)
            test_performance.to_excel(writer_test, sheet_name='Test'+str(fold), index=False) 
                                
    else:
        raise ValueError("Unrecognized model type!")
        
    writer_test.close()
    
    '''
    Load the output spreadsheet and calculate the final walker score and sex estimation
    '''
    # load the probability thresholds and walker score weights (caculated on validation set) for each fold
    # Load the Excel file
    thresh_weights_excel_path = os.path.join(parent_folder_path, 'model__' + args.mdl_type + '__' + args.input_mode, 'Thresholds_Weights.xlsx')
    excel_file = pd.ExcelFile(thresh_weights_excel_path)
    prob_thresholds = pd.read_excel(thresh_weights_excel_path, sheet_name = 'Prob Thresholds')
    if 'Walker Weights' in excel_file.sheet_names:
        walker_weights = pd.read_excel(thresh_weights_excel_path, sheet_name='Walker Weights', dtype={'ColumnName': float})
        print("Sheet 'Walker Weights' loaded successfully.")
    else:
        print("Sheet 'Walker Weights' does not exist in the Excel file.")
        
    all_test_predicts = []
    walker_score_all_test_pred = []
    for fold in range(0,5):
        test_pred_workbook = pd.read_excel(test_performance_save_path, sheet_name = 'Test' + str(fold))
        pred = np.array(test_pred_workbook['Pred prob'].tolist())
        threshold = prob_thresholds['Prob Thresholds'].tolist()[fold]
        predict = np.int8(pred.copy()>threshold)
        all_test_predicts.append(predict)
        
        if if_walker_score:
                      
            walker_score_test_pred = test_pred_workbook.iloc[:,1:8].to_numpy()
            walker_score_all_test_pred.append(walker_score_test_pred)
            
    if if_walker_score:
        
        avg_walker_score_all_pred = average_walkder_scores(walker_score_all_test_pred, walker_weights['Walker Weights'].tolist())
        walker_score_final_pred = round_to_nearest_walker_score(avg_walker_score_all_pred)
        
    vote_test_predict = np.float32(np.mean(all_test_predicts, axis = 0)>0.5)
    pred_str = np.array(['M']*len(vote_test_predict))
    pred_str[vote_test_predict==1]='F'
    
    final_test_results = {'Sample ID': test_pred_workbook['Sample ID'].tolist(),
                          'Pred sex': list(pred_str),                                 
                          }
    
    if if_walker_score:
                
        for k, name in enumerate(keys):
            final_test_results[name] = walker_score_final_pred[:,k].tolist()
            
    final_performance_excel_path = os.path.join(performance_save_folder, 'Final performance.xlsx')    
    with pd.ExcelWriter(final_performance_excel_path, engine='openpyxl') as writer:
        # Convert dictionary to DataFrame
        df = pd.DataFrame.from_dict(final_test_results, orient='index').transpose()
        # Write DataFrame to an Excel sheet
        df.to_excel(writer, sheet_name='Performance', index=False)
        
    end = time.time()
    elapsed = end - start
    elapsed = round(elapsed, 2)
    print("Running took " + str(elapsed) + " secs or " + str(elapsed/60) + " mins in total")