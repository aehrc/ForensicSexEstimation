# -*- coding: utf-8 -*-
"""
Created on Thu Aug 22 15:57:49 2024

@author: Hang Min

Evaluate on validation sets
"""

import os
import sys
# Add the parent directory to the Python path
current_folder = os.path.dirname(os.path.abspath(__file__))
parent_folder_path = os.path.abspath(os.path.join(current_folder, '..'))
sys.path.append(parent_folder_path)
import numpy as np
import time
import argparse
import torch
from torch.utils.data import DataLoader
from networks.resnet import ResNet_two_output, ResNet_auxiliary, ResNet_single_output
import pandas as pd
from data.Custom_data_loader import load_data
from data.Custom_data_loader import load_data_image_skull
from data.Custom_data_loader import load_data_skull
from data.utils import average_walkder_scores, round_to_nearest_walker_score, generate_weights_for_walker_score, mininum_distance_roc
from testing.predict import test_model_two_ouputs, test_model_single_output, assign_value_to_key
from sklearn.metrics import roc_curve

if __name__ == '__main__':
    
    start = time.time() 
    
    parser = argparse.ArgumentParser()
    parser.add_argument('--mdl_name', help='name of the output model', type=str, default="ResNet.pt")
    parser.add_argument('--mdl_type', help='the type of models: ResNet_two_output, ResNet_auxiliary and ResNet_single_output', type=str, default="ResNet_two_output")
    parser.add_argument('--input_mode', help='the type of input: whole CT image, image and skull mask, or skull', type=str, default='skull')
    parser.add_argument('--num_metrics', help='number of Walker traits (bilateral)', type=int, default=7)
    parser.add_argument('--num_classes', help='number of forensic sex classes, 0 (male) or 1 (female). Since this is binary classification, it will be set as 1.', type=int, default=1)
            
    args = parser.parse_args()        
    
       
    # Mapping of model types to functions
    model_functions = {
        "ResNet_two_output": ResNet_two_output,
        "ResNet_auxiliary": ResNet_auxiliary,
        "ResNet_single_output": ResNet_single_output
    }
    
    model_function = model_functions.get(args.mdl_type)
    
    if args.mdl_type ==  "ResNet_single_output":
        if_walker_score = False
    else:
        if_walker_score = True
    '''
    Build model
    '''    
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    
    '''
    Start training the network
    '''    
    data_path = '../Cranial CT data/Cranial CT nifti isotropic crop/'
    seg_path = '../Cranial CT data/Cranial CT isotropic segmentations crop/'
    case_partition_path = '../data_partition/Case_partition.xlsx'
       
    performance_save_folder = os.path.join(parent_folder_path, 'model__' + args.mdl_type + '__' + args.input_mode, 'val')
    os.makedirs(performance_save_folder, exist_ok=True)
    val_performance_save_path = os.path.join(performance_save_folder, 'validation_output.xlsx')
    threshold_weights_save_path = os.path.join(parent_folder_path, 'model__' + args.mdl_type + '__' + args.input_mode, 'Thresholds_Weights.xlsx')
    
    writer_val = pd.ExcelWriter(val_performance_save_path, engine='xlsxwriter')           
    Thresholds_Weights = pd.ExcelWriter(threshold_weights_save_path, engine='xlsxwriter')   
    
    keys = ['GLA\n(1 g)', 'SUP-L\n(2 om)', 'SUP-R\n(3 om)', 'MEN\n(4 em)', 'MAS-L\n(5 ms)', 'MAS-R\n(6 ms)', 'NUC\n(7 nu)']
    Walker_Weights = []
    Prob_Thresholds = []
    '''
    # Perform OOF validation and testing
    '''
    for fold in range(0,5):
        #  Load the out-of-fold validation set
        val_spreadsheet = pd.read_excel(case_partition_path, 'Val'+str(fold))
        
        if  args.input_mode == 'image':
                                   
            # Use image only input
            print('Using whole image as input:')
            val_dataset = load_data(data_path, val_spreadsheet, im_shape = (128,128,128), if_aug = 0)
            
            model = model_function(channel=1, filters=[32, 64, 128, 256], num_metrics=args.num_metrics, num_classes=args.num_classes)
                
        elif args.input_mode == 'image_skull':
            # using image + bone mask
            print('Using image and skull mask as 2 channel inputs, skull mask generated by total segmentator:')
            val_dataset = load_data_image_skull(data_path, val_spreadsheet, seg_path=seg_path, im_shape = (128,128,128), 
                                                      if_aug = 0)
            
            model = model_function(channel=2, filters=[32, 64, 128, 256], num_metrics=args.num_metrics, num_classes=args.num_classes)
            
        elif args.input_mode == 'skull':
            # Using image and bone mask intersection (bone mask region only)
            print('Using skull region intersection between image and skull mask as input, skull mask generated by total segmentator:')
            val_dataset = load_data_skull(data_path, val_spreadsheet, seg_path=seg_path, im_shape = (128,128,128), 
                                                    if_aug = 0)
            
            model = model_function(channel=1, filters=[32, 64, 128, 256], num_metrics=args.num_metrics, num_classes=args.num_classes)
            
        else:
            
            raise ValueError("The input type is not recognized!")

        val_dataLoader = DataLoader(
            dataset = val_dataset,
            batch_size = 1,
            shuffle = False
        )
        print('Number of validation images: ', len(val_dataset))
        
        if_generate_walker_score = False
        
        if args.mdl_type == 'ResNet_two_output' or args.mdl_type == 'ResNet_auxiliary':
                         
            weight_path = os.path.join(parent_folder_path, 'model__' + args.mdl_type + '__' + args.input_mode, 'exp' + str(fold), args.mdl_name)
            
            model.to(device)
            model.load_state_dict(torch.load(weight_path))#, map_location=torch.device('cpu')
            model.eval()
                         
            val_pred1s, val_pred2s = test_model_two_ouputs (val_dataLoader, model, device)
                                        
            val_pred1s = np.array(val_pred1s)
            val_pred2s = np.array(val_pred2s)
            
            val_performance_dict = {'Sample ID': val_spreadsheet['Sample ID'].tolist()}
            val_performance_dict = assign_value_to_key (val_performance_dict, keys, val_pred1s)
            val_performance_dict['Pred prob'] = list(val_pred2s)
            
            val_performance = pd.DataFrame(val_performance_dict)
            val_performance.to_excel(writer_val, sheet_name='Val'+str(fold), index=False) 
            
            if_generate_walker_score = True
                           
        elif args.mdl_type == 'ResNet_single_output': 
              
            weight_path = os.path.join(parent_folder_path, 'model__' + args.mdl_type + '__' + args.input_mode, 'exp' + str(fold), args.mdl_name)
            
            model.to(device)
            model.load_state_dict(torch.load(weight_path))#, map_location=torch.device('cpu')
            model.eval()
                                 
            val_pred2s = test_model_single_output (val_dataLoader, model, device)
            
            val_pred2s = np.array(val_pred2s)
            
            val_performance_dict = {'Sample ID': val_spreadsheet['Sample ID'].tolist()}
            val_performance_dict['Pred prob'] = list(val_pred2s)
            
            val_performance = pd.DataFrame(val_performance_dict)
            val_performance.to_excel(writer_val, sheet_name='Val'+str(fold), index=False) 
                                
        else:
            raise ValueError("Unrecognized model type!")
            
            
        val_sex_gt = np.array(val_spreadsheet['Reported Sex'].tolist()) # ground truth of the forensic sex
        val_sex_gt = np.float32(val_sex_gt=='F')
       
        fprs, tprs, thresholds = roc_curve(val_sex_gt, val_pred2s)
        
        selected_threshold, selected_val_tpr, selected_val_fpr = mininum_distance_roc(tprs, fprs, thresholds)
        
        Prob_Thresholds.append(selected_threshold)
        
        if if_generate_walker_score:
            walker_score_val_pred = val_performance.iloc[:,1:8].to_numpy()  
            walker_weights = generate_weights_for_walker_score(walker_score_val_pred)
            Walker_Weights.append(walker_weights)
            
    Prob_Thresholds_dict = {'Prob Thresholds': Prob_Thresholds}
    Prob_Thresholds_df = pd.DataFrame(Prob_Thresholds_dict)
    Prob_Thresholds_df.to_excel(Thresholds_Weights, sheet_name='Prob Thresholds', index=False) 
       
    Walker_Weights_dict = {'Walker Weights': Walker_Weights}
    Walker_Weights_df = pd.DataFrame(Walker_Weights_dict)
    Walker_Weights_df.to_excel(Thresholds_Weights, sheet_name='Walker Weights', index=False) 
            
    writer_val.close()
    Thresholds_Weights.close()
    